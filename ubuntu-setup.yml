---
- name: Setup Ubuntu 24 System
  hosts: localhost
  connection: local
  become: yes

  vars_files:
    - vars/common.yml

  vars:
    auto_reboot_time: "06:00"  # 6 AM daily reboot

    # Local installer storage for reproducible builds
    installers_base_path: "/opt/installers"

    nvidia_driver_local_repo_url: "https://developer.download.nvidia.com/compute/nvidia-driver/{{ nvidia_driver_version_full }}/local_installers/nvidia-driver-local-repo-ubuntu2404-{{ nvidia_driver_version_full }}_1.0-1_amd64.deb"

    # NOTE: cuda_local_repo_url contains the NVIDIA driver version (580.95.05) â€” update both together.
    cuda_local_repo_url: "https://developer.download.nvidia.com/compute/cuda/{{ cuda_version_full_numeric }}/local_installers/cuda-repo-ubuntu2404-13-0-local_{{ cuda_version_full_numeric }}-{{ nvidia_driver_version_full }}-1_amd64.deb"

    # TensorRT installation method:
    # - "local": Download and use local repository (recommended - guarantees version availability)
    # - "network": Use CUDA network repository (only works while version available)
    # - "auto": Try network first, fall back to local if not found
    tensorrt_install_method: "local"

    # TensorRT local repo URL (auto-constructed if using local method)
    # Override this if you want to use a custom URL or local file path
    tensorrt_local_repo_url: ""
    realvnc_version: "7.13.0"

    log_file: "/var/log/ansible-ubuntu-setup-{{ ansible_date_time.iso8601_basic_short }}.log"
    rtl8812au_usb_id: "0bda:8812"
    rtl8812au_dkms_repo_url: "https://github.com/morrownr/8812au-20210820.git"
    rtl8812au_dkms_repo_version: "main"
    rtl8812au_dkms_repo_path: "{{ installers_base_path }}/8812au-20210820"
    hwe_kernel_meta_package: "linux-generic-hwe-24.04"
    hwe_kernel_headers_meta_package: "linux-headers-generic-hwe-24.04"
    hwe_kernel_pin_enabled: true  # only runs when wifi_setup_strategy == 'hwe_kernel_update' (option 1 at prompt)
    hwe_kernel_pin_version: "6.17.0-14"
    hwe_kernel_flavor: "generic"
    hwe_kernel_require_reboot_before_continue: true
    hwe_kernel_pinned_packages:
      - "linux-image-{{ hwe_kernel_pin_version }}-{{ hwe_kernel_flavor }}"
      - "linux-headers-{{ hwe_kernel_pin_version }}-{{ hwe_kernel_flavor }}"
      - "linux-modules-{{ hwe_kernel_pin_version }}-{{ hwe_kernel_flavor }}"
      - "linux-modules-extra-{{ hwe_kernel_pin_version }}-{{ hwe_kernel_flavor }}"

  tasks:

    - name: (~0%) Validate running as root (become check)
      command: id -u
      register: become_uid_check
      changed_when: false

    - name: (~0%) Fail with clear message if not root
      fail:
        msg: |
          This playbook must run with sudo privileges.
          Run: ansible-playbook ubuntu-setup.yml -K
          Or ensure your sudo timestamp is active (e.g. run 'sudo -v' first).
      when: become_uid_check.stdout | trim != "0"

    # ==========================================================
    # 1. INITIALIZE LOG FILE
    # ==========================================================
    - name: (~0%) Create log directory
      file:
        path: /var/log
        state: directory
        mode: '0755'
    
    - name: (~0%) Initialize log file with header
      copy:
        dest: "{{ log_file }}"
        content: |
          ===================================================================
          Ubuntu 24 System Setup - Started at {{ ansible_date_time.iso8601 }}
          Host: {{ inventory_hostname }}
          ===================================================================

        mode: '0644'
      tags: always

    # ==========================================================
    # 1. PRE-FLIGHT VALIDATION
    # ==========================================================
    - name: (~0%) Check available disk space on /opt
      shell: df -BG /opt | tail -1 | awk '{print $4}' | sed 's/G//'
      register: opt_free_space
      changed_when: false
      failed_when: false

    - name: (~0%) Fail if insufficient disk space
      fail:
        msg: "Insufficient disk space on /opt. Available: {{ opt_free_space.stdout }}GB, Required: 5GB minimum for installers"
      when: opt_free_space.stdout | int < 5

    - name: (~5%) Test network connectivity to NVIDIA
      uri:
        url: "https://developer.download.nvidia.com/"
        method: HEAD
        timeout: 10
        status_code: [200, 301, 302, 403]
      register: nvidia_network_check
      failed_when: false
      changed_when: false

    - name: (~5%) Test network connectivity to CUDA repos
      uri:
        url: "https://developer.download.nvidia.com/compute/cuda/"
        method: HEAD
        timeout: 10
        status_code: [200, 301, 302, 403]
      register: cuda_network_check
      failed_when: false
      changed_when: false

    - debug:
        msg: "âœ… Pre-flight checks passed: {{ opt_free_space.stdout }}GB available, network: {{ 'online' if nvidia_network_check.status is defined else 'offline' }}"

    # ==========================================================
    # 1b. WIFI STRATEGY (first decision)
    # ==========================================================
    - name: (~5%) Prompt for WiFi strategy
      pause:
        prompt: |

          ============================================================
          WIFI STRATEGY
          ============================================================
          Choose the WiFi path for this run:
            1) Standard â€” use existing in-kernel drivers, check WiFi and ethernet  [DEFAULT]
            2) DKMS path â€” build RTL8812AU driver if adapter {{ rtl8812au_usb_id }} is present
            3) HWE kernel (advanced) â€” install/pin kernel 6.17 for RTL8812AU USB WiFi adapter
            4) Manual â€” I will handle WiFi myself
            5) Testing / no WiFi needed for this run

          Press Enter for option 1 (standard).
          Enter 1, 2, 3, 4, or 5
      register: wifi_strategy_prompt

    - name: (~5%) Set WiFi strategy facts
      set_fact:
        wifi_strategy_choice: "{{ (wifi_strategy_prompt.user_input | default('1') | trim) if (wifi_strategy_prompt.user_input | default('1') | trim) in ['1', '2', '3', '4', '5'] else '1' }}"
        wifi_setup_strategy: "{{ {'2': 'dkms_preferred', '3': 'hwe_kernel_update', '4': 'manual', '5': 'manual_test'}.get((wifi_strategy_prompt.user_input | default('1') | trim), 'native_preferred') }}"
        deployment_mode: "{{ 'test' if (wifi_strategy_prompt.user_input | default('1') | trim) in ['4', '5'] else 'production' }}"
        wifi_operator_decision: "{{ '2' if (wifi_strategy_prompt.user_input | default('1') | trim) in ['4', '5'] else '1' }}"

    # ==========================================================
    # 2. HWE KERNEL BASELINE (optional, based on WiFi strategy)
    # ==========================================================
    - name: (~5%) Install Ubuntu 24.04 HWE kernel meta packages
      apt:
        update_cache: yes
        name:
          - "{{ hwe_kernel_meta_package }}"
          - "{{ hwe_kernel_headers_meta_package }}"
        state: present
      register: hwe_kernel_meta_install
      when: wifi_setup_strategy == 'hwe_kernel_update'

    - name: (~5%) Install pinned HWE kernel package set
      apt:
        name: "{{ hwe_kernel_pinned_packages }}"
        state: present
      register: hwe_kernel_pin_install
      when:
        - wifi_setup_strategy == 'hwe_kernel_update'
        - hwe_kernel_pin_enabled | bool

    - name: (~5%) Hold pinned HWE kernel packages
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop: "{{ hwe_kernel_pinned_packages }}"
      when:
        - wifi_setup_strategy == 'hwe_kernel_update'
        - hwe_kernel_pin_enabled | bool

    - name: (~5%) Set kernel baseline facts
      set_fact:
        hwe_target_kernel_release: "{{ hwe_kernel_pin_version }}-{{ hwe_kernel_flavor }}"
        hwe_kernel_active_matches_target: "{{ ansible_kernel == (hwe_kernel_pin_version ~ '-' ~ hwe_kernel_flavor) }}"
        hwe_kernel_native_8812au_supported: "{{ (ansible_kernel.split('-')[0]) is version('6.13', '>=') }}"

    - name: (~5%) Display kernel baseline reminder when reboot is needed
      debug:
        msg: |
          Kernel baseline packages are installed, but the running kernel is still {{ ansible_kernel }}.
          Reboot before relying on native RTL8812AU support (target: {{ hwe_target_kernel_release }}).
      when:
        - wifi_setup_strategy == 'hwe_kernel_update'
        - hwe_kernel_pin_enabled | bool
        - not (hwe_kernel_active_matches_target | bool)

    # ==========================================================
    # 3. KERNEL REBOOT GATE (early exit)
    # ==========================================================
    - name: (~5%) Stop run until pinned kernel is active
      fail:
        msg: |
          Kernel baseline is installed but not active yet.
          Running kernel: {{ ansible_kernel }}
          Required kernel: {{ hwe_target_kernel_release }}
          Reboot now (sudo reboot), then re-run this playbook.
      when:
        - wifi_setup_strategy == 'hwe_kernel_update'
        - hwe_kernel_pin_enabled | bool
        - hwe_kernel_require_reboot_before_continue | bool
        - not (hwe_kernel_active_matches_target | bool)

    # ==========================================================
    # 4. PROMPTS (after kernel baseline gate)
    # ==========================================================

    - name: (~5%) Detect ethernet adapters for boot mode summary
      shell: |
        for iface in /sys/class/net/*; do
          name=$(basename "$iface")
          [ "$name" = "lo" ] && continue
          [ -d "/sys/class/net/$name/wireless" ] && continue
          case "$name" in zt*|tailscale*|docker*|br-*|virbr*|veth*|tun*|tap*|wg*|ppp*) continue ;; esac
          [ -e "/sys/class/net/$name/device" ] || continue
          mac=$(cat "/sys/class/net/$name/address" 2>/dev/null || echo "N/A")
          echo "$name ($mac)"
        done
      register: hw_ethernet_summary
      changed_when: false
      failed_when: false

    - name: (~5%) Detect wireless adapters for boot mode summary
      shell: |
        for iface in /sys/class/net/*; do
          name=$(basename "$iface")
          [ -d "/sys/class/net/$name/wireless" ] && echo "$name"
        done
      register: hw_wifi_summary
      changed_when: false
      failed_when: false

    - name: (~5%) Detect touchscreen for boot mode summary
      shell: lsusb | grep -i -E 'egalax|0eef:'
      register: hw_touchscreen_summary
      changed_when: false
      failed_when: false

    - name: (~5%) Prompt for boot mode
      pause:
        prompt: |

          ============================================================
          DETECTED HARDWARE
          ============================================================
          Ethernet adapters : {{ hw_ethernet_summary.stdout_lines | default([]) | join(', ') or 'none detected' }}
          WiFi interfaces   : {{ hw_wifi_summary.stdout_lines | default([]) | join(', ') or 'none detected' }}
          Touchscreen (USB) : {{ (hw_touchscreen_summary.stdout | trim) if hw_touchscreen_summary.rc == 0 else 'not detected' }}

          ============================================================
          BOOT MODE
          ============================================================
          Do you want:
            1) Minimal X / king_detector (boot to server, no GNOME; xdotool-style)  [DEFAULT]
            2) GNOME on boot (full desktop)

          Press Enter for option 1 (minimal X).
          Enter 1 or 2
      register: boot_mode_prompt

    - name: (~10%) Set boot mode fact
      set_fact:
        boot_mode: "{{ 'gnome' if boot_mode_prompt.user_input | default('1') | trim == '2' else 'minimal_x' }}"

    # ==========================================================
    # 5. WIFI READINESS (early gate before the rest of setup)
    # ==========================================================
    - name: (~10%) Install WiFi detection tools
      apt:
        name:
          - usbutils
          - pciutils
        state: present

    - name: (~10%) Detect expected RTL8812AU adapter
      shell: lsusb | grep -qi "{{ rtl8812au_usb_id }}"
      register: wifi_expected_usb
      changed_when: false
      failed_when: false

    - name: (~10%) Detect other likely USB WiFi adapters
      shell: |
        lsusb | grep -Eiv "{{ rtl8812au_usb_id }}" | grep -Ei 'Wireless|WiFi|WLAN|802\.11|Atheros|Ralink|MediaTek|Qualcomm|Broadcom|Realtek.*(881|882|8723|88)'
      register: wifi_other_usb
      changed_when: false
      failed_when: false

    - name: (~10%) Detect PCIe wireless adapters
      shell: lspci -nn | grep -Ei 'Network controller|Wireless|802\.11'
      register: wifi_pci
      changed_when: false
      failed_when: false

    - name: (~10%) Detect currently working wireless interfaces
      shell: |
        for iface in /sys/class/net/*; do
          iface_name="$(basename "$iface")"
          if [ -d "/sys/class/net/${iface_name}/wireless" ]; then
            echo "${iface_name}"
          fi
        done
      register: wifi_wireless_ifaces
      changed_when: false
      failed_when: false

    - name: (~10%) Set WiFi classification facts
      set_fact:
        rtl8812au_present: "{{ wifi_expected_usb.rc == 0 }}"
        wifi_other_adapter_detected: "{{ (wifi_other_usb.stdout | default('') | trim | length > 0) or (wifi_pci.stdout | default('') | trim | length > 0) }}"
        wifi_native_working: "{{ (wifi_wireless_ifaces.stdout_lines | default([]) | length) > 0 }}"
        rtl8812au_install_status: "not_attempted"

    - name: (~10%) Compute WiFi kernel capability fact
      set_fact:
        wifi_kernel_supports_native_8812au: "{{ (ansible_kernel.split('-')[0]) is version('6.13', '>=') }}"

    - name: (~10%) Compute WiFi decision summary
      set_fact:
        wifi_path: "{{ 'expected_adapter' if (rtl8812au_present | bool) else ('other_adapter' if (wifi_other_adapter_detected | bool) else 'no_adapter') }}"
        wifi_proposed_action: >-
          {% if (wifi_setup_strategy | trim) == 'hwe_kernel_update' %}
          Keep HWE kernel path enforced. If WiFi is still unavailable, reboot into {{ hwe_target_kernel_release }} and re-run.
          {% elif (wifi_setup_strategy | trim) == 'dkms_preferred' and (rtl8812au_present | bool) %}
          Attempt DKMS install for RTL8812AU (morrownr/8812au-20210820) and verify interface appears.
          {% elif (wifi_setup_strategy | trim) == 'dkms_preferred' and not (rtl8812au_present | bool) %}
          DKMS path selected but expected RTL8812AU adapter {{ rtl8812au_usb_id }} is not present.
          {% elif (rtl8812au_present | bool) and (wifi_kernel_supports_native_8812au | bool) and (wifi_native_working | bool) %}
          Use native in-kernel RTL8812AU support (rtw88_8812au); no external driver install.
          {% elif (rtl8812au_present | bool) and (wifi_kernel_supports_native_8812au | bool) and (not wifi_native_working | bool) %}
          RTL8812AU is present and kernel supports it, but no wireless interface is active; fail in production.
          {% elif (rtl8812au_present | bool) and (not wifi_kernel_supports_native_8812au | bool) %}
          Running kernel is too old for native RTL8812AU support; reboot into pinned HWE kernel ({{ hwe_target_kernel_release }}) or fail in production.
          {% elif (wifi_other_adapter_detected | bool) and (wifi_native_working | bool) %}
          Keep native driver (different adapter appears functional); no custom driver install.
          {% elif (wifi_other_adapter_detected | bool) and (not wifi_native_working | bool) %}
          Different adapter detected but no native WiFi interface found; treat as unsupported and fail in production.
          {% else %}
          No WiFi adapter detected; fail in production and continue in test/check mode.
          {% endif %}

    - name: (~10%) Set whether WiFi confirmation prompt is required
      set_fact:
        wifi_confirm_required: "{{ ((wifi_setup_strategy | trim) not in ['manual', 'manual_test']) and (wifi_operator_decision == '1') }}"

    - name: (~10%) Confirm WiFi approach with operator
      pause:
        prompt: |

          ============================================================
          WIFI READINESS DECISION
          ============================================================
          Selected strategy: {{ wifi_setup_strategy }}
          Deployment mode: {{ deployment_mode }}
          Running kernel: {{ ansible_kernel }}
          Native RTL8812AU support on running kernel: {{ wifi_kernel_supports_native_8812au }}
          Expected adapter ({{ rtl8812au_usb_id }}): {{ 'present' if rtl8812au_present else 'absent' }}
          Other adapter detected: {{ wifi_other_adapter_detected }}
          Working wireless interfaces: {{ (wifi_wireless_ifaces.stdout_lines | default([]) | join(', ')) if (wifi_wireless_ifaces.stdout_lines | default([]) | length > 0) else 'none' }}

          Proposed action:
          {{ wifi_proposed_action }}

          Choose:
            1) Proceed with proposed action  [DEFAULT]
            2) Skip WiFi changes/check enforcement for this run
            3) Abort run now

          Press Enter to proceed.
          Enter 1, 2, or 3
      register: wifi_plan_prompt
      when: wifi_confirm_required | bool

    - name: (~15%) Set WiFi operator decision from confirmation prompt
      set_fact:
        wifi_operator_decision: "{{ (wifi_plan_prompt.user_input | default('1') | trim) if (wifi_plan_prompt.user_input | default('1') | trim) in ['1', '2', '3'] else '1' }}"
      when: wifi_confirm_required | bool

    - name: (~15%) Keep WiFi operator decision from initial strategy choice
      debug:
        msg: "WiFi decision pre-selected earlier (strategy={{ wifi_setup_strategy }}, decision={{ wifi_operator_decision }}); skipping readiness confirmation prompt."
      when: not (wifi_confirm_required | bool)

    - name: (~15%) Abort on operator request
      fail:
        msg: "Operator aborted during WiFi readiness decision."
      when: wifi_operator_decision == '3'

    - name: (~15%) Install DKMS prerequisites for RTL8812AU (strategy option 2)
      apt:
        name:
          - dkms
          - bc
          - git
          - build-essential
          - linux-headers-generic
        state: present
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - rtl8812au_present | bool

    - name: (~15%) Fetch RTL8812AU DKMS source
      git:
        repo: "{{ rtl8812au_dkms_repo_url }}"
        dest: "{{ rtl8812au_dkms_repo_path }}"
        version: "{{ rtl8812au_dkms_repo_version }}"
        update: yes
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - rtl8812au_present | bool

    - name: (~15%) Run RTL8812AU DKMS installer
      command: bash install-driver.sh NoPrompt
      args:
        chdir: "{{ rtl8812au_dkms_repo_path }}"
      register: rtl8812au_dkms_install
      changed_when: true
      failed_when:
        - deployment_mode == 'production'
        - rtl8812au_dkms_install.rc != 0
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - rtl8812au_present | bool

    - name: (~15%) Refresh module dependency map after RTL8812AU DKMS install
      command: depmod -a
      changed_when: true
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - rtl8812au_present | bool

    - name: (~15%) Load RTL8812AU module after DKMS install
      command: modprobe 8812au
      register: rtl8812au_modprobe
      changed_when: true
      failed_when:
        - deployment_mode == 'production'
        - rtl8812au_modprobe.rc != 0
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - rtl8812au_present | bool

    - name: (~15%) Re-detect wireless interfaces after DKMS path
      shell: |
        for iface in /sys/class/net/*; do
          iface_name="$(basename "$iface")"
          if [ -d "/sys/class/net/${iface_name}/wireless" ]; then
            echo "${iface_name}"
          fi
        done
      register: wifi_wireless_ifaces_after_dkms
      changed_when: false
      failed_when: false
      retries: 5
      delay: 2
      until: (wifi_wireless_ifaces_after_dkms.stdout_lines | default([]) | length) > 0
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - rtl8812au_present | bool

    - name: (~15%) Update WiFi working fact after DKMS path
      set_fact:
        wifi_native_working: "{{ (wifi_wireless_ifaces_after_dkms.stdout_lines | default([]) | length) > 0 }}"
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - rtl8812au_present | bool

    - name: (~15%) Enforce production policy for missing WiFi adapter
      fail:
        msg: "No WiFi adapter detected. Production mode requires a WiFi adapter."
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'production'
        - wifi_path == 'no_adapter'

    - name: (~20%) Enforce production policy for unsupported non-native adapter
      fail:
        msg: "A non-RTL8812AU adapter was detected but no native wireless interface is available. Production mode requires a working WiFi adapter."
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'production'
        - wifi_path == 'other_adapter'
        - not (wifi_native_working | bool)

    - name: (~20%) Enforce production policy when RTL8812AU adapter is not working after DKMS path
      fail:
        msg: "RTL8812AU adapter was detected and DKMS install was attempted, but no wireless interface is active. Fix adapter/driver state and re-run the playbook."
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'production'
        - wifi_setup_strategy == 'dkms_preferred'
        - wifi_path == 'expected_adapter'
        - not (wifi_native_working | bool)

    - name: (~20%) Enforce production policy when RTL8812AU adapter is not working natively
      fail:
        msg: "RTL8812AU adapter was detected but no native wireless interface is active on kernel {{ ansible_kernel }}. Reboot into {{ hwe_target_kernel_release }} or fix adapter state."
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'production'
        - wifi_setup_strategy != 'dkms_preferred'
        - wifi_path == 'expected_adapter'
        - not (wifi_native_working | bool)

    - name: (~20%) Warn when RTL8812AU adapter is present but not active (test mode)
      debug:
        msg: "RTL8812AU adapter is present but no wireless interface is active on kernel {{ ansible_kernel }}. Continuing because deployment mode is test/check."
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'test'
        - wifi_path == 'expected_adapter'
        - not (wifi_native_working | bool)

    - name: (~20%) Warn about non-native adapter without working wireless interface (test mode)
      debug:
        msg: "Non-RTL8812AU adapter detected, but no wireless interface is up natively. Continuing because deployment mode is test/check."
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'test'
        - wifi_path == 'other_adapter'
        - not (wifi_native_working | bool)

    - name: (~20%) Mark WiFi status when RTL8812AU adapter works after DKMS path
      set_fact:
        rtl8812au_install_status: "dkms_expected_adapter_ok"
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy == 'dkms_preferred'
        - wifi_path == 'expected_adapter'
        - wifi_native_working | bool

    - name: (~20%) Mark WiFi status when RTL8812AU adapter is working natively
      set_fact:
        rtl8812au_install_status: "native_expected_adapter_ok"
      when:
        - wifi_operator_decision == '1'
        - wifi_setup_strategy != 'dkms_preferred'
        - wifi_path == 'expected_adapter'
        - wifi_native_working | bool

    - name: (~20%) Mark WiFi status when RTL8812AU adapter is present but not active (test mode)
      set_fact:
        rtl8812au_install_status: "expected_adapter_not_working_test"
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'test'
        - wifi_path == 'expected_adapter'
        - not (wifi_native_working | bool)

    - name: (~20%) Mark WiFi status when using native non-RTL adapter
      set_fact:
        rtl8812au_install_status: "native_adapter_ok"
      when:
        - wifi_operator_decision == '1'
        - wifi_path == 'other_adapter'
        - wifi_native_working | bool

    - name: (~20%) Mark WiFi status when no adapter is acceptable in test mode
      set_fact:
        rtl8812au_install_status: "no_adapter_allowed_test"
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'test'
        - wifi_path == 'no_adapter'

    - name: (~20%) Mark WiFi status when non-native adapter is not working (test mode)
      set_fact:
        rtl8812au_install_status: "other_adapter_not_working_test"
      when:
        - wifi_operator_decision == '1'
        - deployment_mode == 'test'
        - wifi_path == 'other_adapter'
        - not (wifi_native_working | bool)

    - name: (~25%) Mark WiFi status when operator skipped WiFi handling
      set_fact:
        rtl8812au_install_status: "skipped_by_operator"
      when: wifi_operator_decision == '2'

    - name: (~25%) Report WiFi readiness outcome
      debug:
        msg: "WiFi readiness outcome: {{ rtl8812au_install_status }}"

    # ==========================================================
    # 5. CREATE LOCAL INSTALLER STORAGE
    # ==========================================================
    - name: (~25%) Create local installer base directory
      file:
        path: "{{ installers_base_path }}"
        state: directory
        mode: '0755'
        owner: root
        group: root

    - name: (~25%) Create nvidia-driver installer directory
      file:
        path: "{{ installers_base_path }}/nvidia-driver"
        state: directory
        mode: '0755'

    - name: (~25%) Create cuda installer directory
      file:
        path: "{{ installers_base_path }}/cuda"
        state: directory
        mode: '0755'

    - name: (~25%) Create tensorrt installer directory
      file:
        path: "{{ installers_base_path }}/tensorrt"
        state: directory
        mode: '0755'

    - name: (~25%) Create version manifest
      copy:
        dest: "{{ installers_base_path }}/VERSIONS.json"
        mode: '0644'
        content: |
          {
            "manifest_created": "{{ ansible_date_time.iso8601 }}",
            "hostname": "{{ ansible_hostname }}",
            "ubuntu_version": "{{ ansible_distribution_version }}",
            "components": {
              "nvidia_driver": {
                "version": "{{ nvidia_driver_version_full }}",
                "method": "local_repository",
                "url": "{{ nvidia_driver_local_repo_url }}"
              },
              "cuda_toolkit": {
                "version": "{{ cuda_version_full_numeric }}",
                "method": "local_repository",
                "url": "{{ cuda_local_repo_url }}"
              },
              "tensorrt": {
                "version": "{{ tensorrt_version_full }}",
                "method": "{{ tensorrt_install_method }}",
                "url": "{{ tensorrt_local_repo_url if tensorrt_local_repo_url else 'auto-constructed' }}"
              },
              "pytorch_cuda": {
                "version": "cu130",
                "note": "Installed via pip in post-reboot-verify.yml"
              }
            },
            "reproducibility": {
              "local_installers": "{{ installers_base_path }}",
              "package_holding": "dpkg hold on nvidia-*-{{ nvidia_driver_version }}, cuda-*-{{ cuda_version }}, tensorrt-*",
              "unattended_upgrades_blacklist": "/etc/apt/apt.conf.d/51nvidia-blacklist",
              "apt_preferences": "/etc/apt/preferences.d/99-gpu-stack-pinning"
            }
          }

    - debug:
        msg: "ðŸ“‹ Version manifest created at {{ installers_base_path }}/VERSIONS.json"

    - name: (~25%) Create SHA-256 checksums placeholder file
      copy:
        dest: "{{ installers_base_path }}/SHA256SUMS"
        mode: '0644'
        content: |
          # SHA-256 Checksums for GPU Stack Installers
          # Generated: {{ ansible_date_time.iso8601 }}
          # Verify with: cd /opt/installers && sha256sum -c SHA256SUMS
          #
          # Checksums will be appended during installation
        force: no

    # ==========================================================
    # 6. SYSTEM UPDATE
    # ==========================================================
    - name: (~25%) Update apt cache and upgrade packages
      apt:
        update_cache: yes
        cache_valid_time: 3600
        upgrade: dist
      register: apt_upgrade
    
    - debug: msg="âœ… System updated successfully."

    # ==========================================================
    # 7. COMMON UTILITIES & MONITORING TOOLS
    # ==========================================================
    - name: (~25%) Install general developer and monitoring tools
      apt:
        name:
          - build-essential
          - git
          - cmake
          - unzip
          - zip
          - wget
          - curl
          - vim
          - nano
          - tree
          - jq
          - netcat-traditional
          - psmisc
          - htop
          - btop
          - bmon
          - iftop
          - nvtop
          - wavemon
          - net-tools
          - lm-sensors
          - speedtest-cli
        state: present
      register: tools_install
    
    - name: (~25%) Print versions of installed core tools
      shell: |
        echo "htop: $(htop --version | head -n1)"
        echo "git: $(git --version)"
        echo "cmake: $(cmake --version | head -n1)"
      register: base_versions
    
    - name: (~25%) Display installed tool versions
      debug:
        msg: "{{ base_versions.stdout_lines }}"

    - name: (~30%) Install xdotool and x11-xserver-utils for minimal X / king_detector
      apt: { name: [xdotool, x11-xserver-utils], state: present }
      when: boot_mode == 'minimal_x'

    # ==========================================================
    # 3. SSH CONFIGURATION
    # ==========================================================
    - name: (~30%) Install and configure OpenSSH server
      apt: { name: openssh-server, state: present }

    - name: (~30%) Ensure .ssh directory exists for user
      file:
        path: "{{ user_home }}/.ssh"
        state: directory
        mode: '0700'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"

    - name: (~30%) Check if ssh-public-keys.txt exists in repo
      stat:
        path: "{{ playbook_dir }}/ssh-public-keys.txt"
      register: ssh_keys_file
      delegate_to: localhost
      run_once: true

    - name: (~30%) Read SSH keys from file
      slurp:
        src: "{{ playbook_dir }}/ssh-public-keys.txt"
      register: ssh_keys_content
      when: ssh_keys_file.stat.exists | default(false)

    - name: (~30%) Deploy SSH keys from ssh-public-keys.txt to authorized_keys
      authorized_key:
        user: "{{ ssh_user }}"
        key: "{{ item }}"
        state: present
      loop: "{{ (ssh_keys_content.content | default('') | b64decode).split('\n') | map('trim') | select() | select('search', '^ssh-') | list }}"
      when:
        - ssh_keys_content.content is defined
        - item | length > 0

    - name: (~30%) Set SSH Port in sshd_config (single place)
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?\s*Port\s+'
        line: "Port {{ ssh_port }}"
      notify: restart sshd

    - name: (~30%) Set PasswordAuthentication no in sshd_config
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?\s*PasswordAuthentication\s+'
        line: "PasswordAuthentication no"
      notify: restart sshd

    - name: (~30%) Set PubkeyAuthentication yes in sshd_config
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?\s*PubkeyAuthentication\s+'
        line: "PubkeyAuthentication yes"
      notify: restart sshd

    - name: (~30%) Set PermitRootLogin no in sshd_config
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?\s*PermitRootLogin\s+'
        line: "PermitRootLogin no"
      notify: restart sshd

    - name: (~30%) Validate sshd_config
      command: /usr/sbin/sshd -t -f /etc/ssh/sshd_config
      changed_when: false

    - debug: msg="âœ… SSH configured on port {{ ssh_port }}"

    # ==========================================================
    # 4. FIREWALL
    # ==========================================================
    - name: (~35%) Install and enable UFW
      apt: { name: ufw, state: present }
    - name: (~35%) Allow SSH through UFW
      ufw: { rule: allow, port: "{{ ssh_port }}", proto: tcp }
    - name: (~35%) Enable UFW non-interactively
      command: ufw --force enable
      args: { creates: /etc/ufw/ufw.conf }
      register: ufw_enable
    
    - debug: msg="âœ… UFW enabled with SSH port {{ ssh_port }} open."

    # ==========================================================
    # 5b. DATA FOLDERS (videos and jpgs for app)
    # ==========================================================
    - name: (~35%) Ensure app data base path exists
      file:
        path: "{{ app_data_path }}"
        state: directory
        mode: '0755'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"

    - name: (~35%) Create app data directory structure
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"
      loop:
        - "{{ app_data_path }}"
        - "{{ app_data_path }}/jpg"
        - "{{ app_data_path }}/video"
        - "{{ app_data_path }}/jpg/no_hook"
        - "{{ app_data_path }}/jpg/no_overlay"
        - "{{ app_data_path }}/ad_hoc"
        - "{{ app_data_path }}/ad_hoc/jpg"
        - "{{ app_data_path }}/ad_hoc/video"

    # ==========================================================
    # 5c. SCHEDULED REBOOT (root cron at 6 and 18)
    # ==========================================================
    - name: (~35%) Install root cron for scheduled reboot at 6 and 18
      cron:
        name: "Scheduled reboot at 6 and 18"
        user: root
        minute: "0"
        hour: "6,18"
        job: /sbin/reboot

    - name: (~35%) Install root cron to log cron execution (6 and 18)
      cron:
        name: "Cron test log at 6 and 18"
        user: root
        minute: "0"
        hour: "6,18"
        job: 'echo "Cron executed at $(date)" >> /var/log/cron_test.log'

    # ==========================================================
    # 6. TAILSCALE
    # ==========================================================
    - name: (~35%) Setup Tailscale repository and install
      block:
        - name: (~35%) Create keyrings directory for Tailscale
          file:
            path: /usr/share/keyrings
            state: directory
            mode: '0755'

        - name: (~35%) Download Tailscale GPG key
          get_url:
            url: https://pkgs.tailscale.com/stable/ubuntu/noble.noarmor.gpg
            dest: /usr/share/keyrings/tailscale-archive-keyring.gpg
            mode: '0644'

        - name: (~35%) Download Tailscale repository list
          get_url:
            url: https://pkgs.tailscale.com/stable/ubuntu/noble.tailscale-keyring.list
            dest: /etc/apt/sources.list.d/tailscale.list
            mode: '0644'

        - name: (~40%) Update apt cache for Tailscale
          apt:
            update_cache: yes

        - name: (~40%) Install Tailscale
          apt:
            name: tailscale
            state: present

        - name: (~40%) Enable and start tailscaled service
          systemd:
            name: tailscaled
            enabled: yes
            state: started

        - shell: echo "âœ… Tailscale installed. Run 'sudo tailscale up' to authenticate." >> {{ log_file }}
      rescue:
        - debug: msg="âš ï¸ Tailscale repo or install failed."
        - shell: echo "âš ï¸ Tailscale repo or install failed." >> {{ log_file }}
    
    - debug: msg="âœ… Tailscale installed. Run 'sudo tailscale up' to authenticate."

    # ==========================================================
    # 7. REALVNC SERVER
    # ==========================================================
    - name: (~40%) Install RealVNC
      block:
        - get_url:
            url: "https://downloads.realvnc.com/download/file/vnc.files/VNC-Server-{{ realvnc_version }}-Linux-x64.deb"
            dest: /tmp/realvnc-server.deb
            timeout: 60
        - apt: { deb: /tmp/realvnc-server.deb }
        - shell: echo "âœ… RealVNC {{ realvnc_version }} installed." >> {{ log_file }}
        - debug: msg="âœ… RealVNC {{ realvnc_version }} installed."
      rescue:
        - debug: msg="âš ï¸ RealVNC download failed."
        - shell: echo "âš ï¸ RealVNC download failed." >> {{ log_file }}
    
    # ==========================================================
    # 8. VISUAL STUDIO CODE
    # ==========================================================
    - name: (~40%) Install Visual Studio Code
      block:
        - name: (~40%) Create keyrings directory for VS Code
          file:
            path: /usr/share/keyrings
            state: directory
            mode: '0755'

        - name: (~40%) Download Microsoft GPG key
          get_url:
            url: https://packages.microsoft.com/keys/microsoft.asc
            dest: /tmp/microsoft.asc
            mode: '0644'

        - name: (~40%) Install Microsoft GPG key
          shell: gpg --dearmor < /tmp/microsoft.asc > /usr/share/keyrings/microsoft.gpg
          args:
            creates: /usr/share/keyrings/microsoft.gpg

        - name: (~40%) Add VS Code repository
          apt_repository:
            repo: "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/vscode stable main"
            state: present
            filename: vscode
            update_cache: yes

        - name: (~40%) Install VS Code package
          apt:
            name: code
            state: present

        - shell: echo "âœ… VS Code installed." >> {{ log_file }}
        - debug: msg="âœ… VS Code installed."
      rescue:
        - debug: msg="âš ï¸ VS Code repo or install failed."
        - shell: echo "âš ï¸ VS Code repo or install failed." >> {{ log_file }}
    
    # ==========================================================
    # 9. DISPLAY SERVER (XORG) & VM DETECTION
    # ==========================================================
    - name: (~40%) Detect if running in a virtual machine
      shell: systemd-detect-virt
      register: virt_detect
      failed_when: false
      changed_when: false

    - name: (~45%) Set VM detection fact
      set_fact:
        is_virtual_machine: "{{ virt_detect.rc == 0 and virt_detect.stdout != 'none' }}"
        virtualization_type: "{{ virt_detect.stdout | default('none') }}"

    - name: (~45%) Check if GDM3 is installed
      stat:
        path: /etc/gdm3/custom.conf
      register: gdm3_config

    - name: (~45%) Check if LightDM is installed
      stat:
        path: /etc/lightdm/lightdm.conf
      register: lightdm_config

    - name: (~45%) Disable Wayland and force Xorg (GDM3)
      lineinfile:
        path: /etc/gdm3/custom.conf
        regexp: '^#?WaylandEnable='
        line: 'WaylandEnable=false'
        insertafter: '^\[daemon\]'
        backup: yes
      notify: restart gdm3
      register: xorg_config_gdm3
      when: gdm3_config.stat.exists

    - name: (~45%) Configure LightDM to use Xorg (if present)
      lineinfile:
        path: /etc/lightdm/lightdm.conf
        regexp: '^#?user-session='
        line: 'user-session=xubuntu'
        insertafter: '^\[Seat:\*\]'
        backup: yes
      notify: restart lightdm
      register: xorg_config_lightdm
      when: lightdm_config.stat.exists

    - name: (~45%) Apply VM-specific display fix (QXL)
      block:
        - name: (~45%) Create X11 config directory
          file:
            path: /etc/X11/xorg.conf.d
            state: directory
            mode: '0755'

        - name: (~45%) Configure QXL display for VMs
          copy:
            dest: /etc/X11/xorg.conf.d/10-qxl-display.conf
            mode: '0644'
            content: |
              Section "ServerFlags"
                  Option "AutoAddGPU" "false"
              EndSection

              Section "ServerLayout"
                  Identifier "Layout0"
                  Screen 0 "Screen0"
              EndSection

              Section "Device"
                  Identifier "QXL"
                  Driver "qxl"
                  BusID "PCI:0:1:0"
              EndSection

              Section "Screen"
                  Identifier "Screen0"
                  Device "QXL"
              EndSection
          notify:
            - restart gdm3
            - restart lightdm

        - name: (~45%) Remove conflicting NVIDIA X11 config
          file:
            path: /etc/X11/xorg.conf.d/10-nvidia.conf
            state: absent
          notify:
            - restart gdm3
            - restart lightdm

        - shell: |
            echo "âœ… VM detected ({{ virtualization_type }}): Applied QXL display fix" >> {{ log_file }}

        - debug:
            msg: "âœ… VM detected ({{ virtualization_type }}): Applied QXL display fix"

      when: is_virtual_machine

    - debug:
        msg: |
          âœ… Display configured for Xorg (Wayland disabled)
          System: {{ 'Virtual Machine (' + virtualization_type + ')' if is_virtual_machine else 'Physical/Bare Metal' }}

    # ==========================================================
    # 10. NVIDIA DRIVER & GRUB CONFIG (LOCAL REPO)
    # ==========================================================
    - name: (~45%) Install NVIDIA driver from local repository
      block:
        - name: (~45%) Download NVIDIA driver local repository package
          get_url:
            url: "{{ nvidia_driver_local_repo_url }}"
            dest: "{{ installers_base_path }}/nvidia-driver/nvidia-driver-local-repo.deb"
            mode: '0644'
            timeout: 300
          register: nvidia_driver_download

        - name: (~50%) Calculate SHA-256 checksum of NVIDIA driver package
          shell: sha256sum {{ installers_base_path }}/nvidia-driver/nvidia-driver-local-repo.deb | awk '{print $1}'
          register: nvidia_driver_sha256
          changed_when: false
          when: nvidia_driver_download.changed

        - name: (~50%) Log NVIDIA driver SHA-256 checksum
          shell: |
            echo "NVIDIA Driver SHA-256: {{ nvidia_driver_sha256.stdout }}" >> {{ log_file }}
            echo "  File: nvidia-driver-local-repo.deb" >> {{ log_file }}
            echo "  Downloaded: {{ ansible_date_time.iso8601 }}" >> {{ log_file }}
            echo "{{ nvidia_driver_sha256.stdout }}  nvidia-driver/nvidia-driver-local-repo.deb" >> {{ installers_base_path }}/SHA256SUMS
          when: nvidia_driver_download.changed

        - name: (~50%) Install NVIDIA driver local repository package
          apt:
            deb: "{{ installers_base_path }}/nvidia-driver/nvidia-driver-local-repo.deb"
            state: present

        - name: (~50%) Find NVIDIA driver repository directory
          shell: find /var -maxdepth 1 -type d -name 'nvidia-driver-local-repo-*' | head -n 1
          register: nvidia_repo_dir
          changed_when: false

        - name: (~50%) Copy NVIDIA driver GPG key to keyrings
          shell: cp {{ nvidia_repo_dir.stdout }}/nvidia-*-keyring.gpg /usr/share/keyrings/
          args:
            creates: /usr/share/keyrings/nvidia-*-keyring.gpg
          when: nvidia_repo_dir.stdout != ""

        - name: (~50%) Update apt cache with NVIDIA driver repository
          apt:
            update_cache: yes

        - name: (~50%) Install NVIDIA driver meta-package
          apt:
            name: "nvidia-driver-{{ nvidia_driver_version }}"
            state: present
            update_cache: yes
          register: nvidia_driver_install

        - name: (~50%) Configure GRUB for NVIDIA KMS
          lineinfile:
            path: /etc/default/grub
            regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
            line: 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash nvidia-drm.modeset=1"'
            backup: yes
          register: grub_updated

        - name: (~50%) Update GRUB configuration
          command: update-grub
          when: grub_updated.changed

        - name: (~50%) Configure NVIDIA modprobe options
          copy:
            dest: /etc/modprobe.d/nvidia.conf
            mode: '0644'
            content: |
              options nvidia-drm modeset=1
              options nvidia NVreg_PreserveVideoMemoryAllocations=1

        - shell: echo "âœ… NVIDIA driver {{ nvidia_driver_version_full }} installed from local repository." >> {{ log_file }}

    - debug: msg="âœ… NVIDIA driver {{ nvidia_driver_version_full }} installed from local repository."

    # Hold NVIDIA driver packages to prevent upgrades
    - name: (~50%) Get list of installed NVIDIA driver packages
      shell: dpkg -l | grep '^ii' | grep -E 'nvidia.*-{{ nvidia_driver_version }}' | awk '{print $2}'
      register: nvidia_packages_list
      changed_when: false
      failed_when: false

    - name: (~55%) Hold NVIDIA driver packages
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop: "{{ nvidia_packages_list.stdout_lines }}"
      when: nvidia_packages_list.stdout_lines | length > 0

    - name: (~55%) Verify NVIDIA driver packages are held
      shell: dpkg --get-selections | grep -E 'nvidia.*-{{ nvidia_driver_version }}' | grep hold
      register: nvidia_held_packages
      changed_when: false
      failed_when: nvidia_held_packages.rc != 0

    - debug:
        msg: "ðŸ”’ {{ nvidia_held_packages.stdout_lines | length }} NVIDIA driver packages held to prevent upgrades"

    # ==========================================================
    # 11. CUDA TOOLKIT (LOCAL REPO)
    # ==========================================================
    - name: (~55%) Install CUDA Toolkit from local repository
      block:
        - name: (~55%) Download CUDA local repository package
          get_url:
            url: "{{ cuda_local_repo_url }}"
            dest: "{{ installers_base_path }}/cuda/cuda-repo-local.deb"
            mode: '0644'
            timeout: 600
          register: cuda_download

        - name: (~55%) Calculate SHA-256 checksum of CUDA package
          shell: sha256sum {{ installers_base_path }}/cuda/cuda-repo-local.deb | awk '{print $1}'
          register: cuda_sha256
          changed_when: false
          when: cuda_download.changed

        - name: (~55%) Log CUDA SHA-256 checksum
          shell: |
            echo "CUDA Toolkit SHA-256: {{ cuda_sha256.stdout }}" >> {{ log_file }}
            echo "  File: cuda-repo-local.deb" >> {{ log_file }}
            echo "  Downloaded: {{ ansible_date_time.iso8601 }}" >> {{ log_file }}
            echo "{{ cuda_sha256.stdout }}  cuda/cuda-repo-local.deb" >> {{ installers_base_path }}/SHA256SUMS
          when: cuda_download.changed

        - name: (~55%) Install CUDA local repository package
          apt:
            deb: "{{ installers_base_path }}/cuda/cuda-repo-local.deb"
            state: present

        - name: (~55%) Find CUDA repository directory
          shell: find /var -maxdepth 1 -type d -name 'cuda-repo-ubuntu2404-*-local' | head -n 1
          register: cuda_repo_dir
          changed_when: false

        - name: (~55%) Copy CUDA GPG key to keyrings
          shell: cp {{ cuda_repo_dir.stdout }}/cuda-*-keyring.gpg /usr/share/keyrings/
          args:
            creates: /usr/share/keyrings/cuda-*-keyring.gpg
          when: cuda_repo_dir.stdout != ""

        - name: (~55%) Update apt cache with CUDA repository
          apt:
            update_cache: yes

        - name: (~55%) Install CUDA toolkit package
          apt:
            name: "cuda-toolkit-{{ cuda_version }}"
            state: present
            update_cache: yes

        - name: (~60%) Configure CUDA environment in /etc/profile.d/
          copy:
            dest: /etc/profile.d/cuda.sh
            mode: '0644'
            content: |
              export PATH=/usr/local/cuda-{{ cuda_version_full }}/bin:$PATH
              export LD_LIBRARY_PATH=/usr/local/cuda-{{ cuda_version_full }}/lib64:$LD_LIBRARY_PATH

        - name: (~60%) Configure CUDA library path for ldconfig
          copy:
            dest: /etc/ld.so.conf.d/cuda.conf
            mode: '0644'
            content: |
              /usr/local/cuda-{{ cuda_version_full }}/lib64
          notify: update ldconfig

        - shell: echo "âœ… CUDA {{ cuda_version_full }} installed from local repository." >> {{ log_file }}
        - debug: msg="âœ… CUDA {{ cuda_version_full }} installed from local repository."
      rescue:
        - debug: msg="âš ï¸ CUDA installation failed."
        - shell: echo "âš ï¸ CUDA installation failed." >> {{ log_file }}

    # Hold CUDA packages to prevent upgrades
    - name: (~60%) Get list of installed CUDA 13-0 packages
      shell: dpkg -l | grep -E '^ii' | awk '{print $2}' | grep 'cuda.*-13-0$'
      register: installed_cuda_packages
      changed_when: false
      failed_when: false

    - name: (~60%) Hold installed CUDA packages to prevent upgrades
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop: "{{ installed_cuda_packages.stdout_lines }}"
      when: installed_cuda_packages.stdout_lines | length > 0

    - name: (~60%) Get list of all installed CUDA packages for holding
      shell: dpkg -l | grep '^ii' | grep -E 'cuda-|libcu' | grep '{{ cuda_version }}' | awk '{print $2}'
      register: additional_cuda_packages
      changed_when: false
      failed_when: false

    - name: (~60%) Hold additional CUDA packages
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop: "{{ additional_cuda_packages.stdout_lines }}"
      when: additional_cuda_packages.stdout_lines | length > 0

    - name: (~60%) Verify CUDA packages are held
      shell: dpkg --get-selections | grep -E 'cuda-|libcu' | grep '{{ cuda_version }}' | grep hold
      register: cuda_held_packages
      changed_when: false
      failed_when: false

    - debug:
        msg: "ðŸ”’ {{ cuda_held_packages.stdout_lines | length }} CUDA packages held to prevent upgrades"

    # ==========================================================
    # 12. TENSORRT
    # ==========================================================
    - name: (~60%) Install TensorRT with version pinning
      block:
        # Detect Ubuntu version and architecture
        - name: (~60%) Get Ubuntu codename
          shell: . /etc/os-release && echo "$VERSION_CODENAME"
          register: ubuntu_codename
          changed_when: false

        - name: (~60%) Get system architecture
          command: dpkg --print-architecture
          register: system_arch
          changed_when: false

        - name: (~60%) Construct TensorRT local repo URL automatically
          set_fact:
            tensorrt_auto_url: "https://developer.download.nvidia.com/compute/tensorrt/{{ tensorrt_version_full }}/local_installers/nv-tensorrt-local-repo-ubuntu{{ ansible_distribution_version | replace('.', '') }}-{{ tensorrt_version_full }}-cuda-{{ cuda_version_full }}_1.0-1_{{ system_arch.stdout }}.deb"

        - name: (~65%) Set final TensorRT URL
          set_fact:
            tensorrt_final_url: "{{ tensorrt_local_repo_url if tensorrt_local_repo_url != '' else tensorrt_auto_url }}"

        - name: (~65%) Display TensorRT installation plan
          debug:
            msg: |
              TensorRT Installation Configuration:
              - Method: {{ tensorrt_install_method }}
              - Version: {{ tensorrt_version_full }}
              - CUDA: {{ cuda_version_full }}
              - Ubuntu: {{ ubuntu_codename.stdout }}
              - Architecture: {{ system_arch.stdout }}
              {% if tensorrt_install_method == 'local' %}
              - Local repo URL: {{ tensorrt_final_url }}
              {% endif %}

        # Method 1: Local Repository
        - name: (~65%) Install TensorRT from local repository
          when: tensorrt_install_method == 'local' or tensorrt_install_method == 'auto'
          block:
            - name: (~65%) Download TensorRT local repo package
              get_url:
                url: "{{ tensorrt_final_url }}"
                dest: /tmp/tensorrt-local-repo.deb
                timeout: 300
              register: tensorrt_download
              failed_when: false

            - name: (~65%) Install TensorRT local repo package
              apt:
                deb: /tmp/tensorrt-local-repo.deb
              when: tensorrt_download is succeeded

            - name: (~65%) Copy TensorRT repo keyring
              shell: cp /var/nv-tensorrt-local-repo-*/tensorrt-*-keyring.gpg /usr/share/keyrings/ 2>/dev/null || cp /var/nv-tensorrt-local-repo-*/*-keyring.gpg /usr/share/keyrings/
              when: tensorrt_download is succeeded
              register: keyring_copy
              failed_when: false

            - name: (~65%) Update apt cache for TensorRT local repo
              apt:
                update_cache: yes
              when: tensorrt_download is succeeded

            - name: (~65%) Install TensorRT from local repo
              apt:
                name:
                  - tensorrt-dev
                  - tensorrt-libs
                  - python3-libnvinfer
                  - python3-libnvinfer-dev
                state: present
              when: tensorrt_download is succeeded
              register: trt_local_install

        # Method 2: Network Repository (when local fails or method is "network")
        - name: (~65%) Install TensorRT from network repository
          when: (tensorrt_install_method == 'network') or (tensorrt_install_method == 'auto' and (tensorrt_download is failed or trt_local_install is failed))
          block:
            - name: (~65%) Update apt cache for TensorRT
              apt:
                update_cache: yes

            - name: (~65%) Check available TensorRT versions in network repo
              shell: apt-cache madison tensorrt-dev | grep "{{ tensorrt_version_pattern }}" | head -1 | awk '{print $3}'
              register: available_trt_version
              failed_when: false
              changed_when: false

            - name: (~70%) Fail if requested TensorRT version not available
              fail:
                msg: |
                  TensorRT {{ tensorrt_version_pattern }} not found in network repository!

                  When newer TensorRT versions are released, NVIDIA removes old versions from the network repo.

                  SOLUTION: Set tensorrt_install_method to "local" or "auto" to use local repository.
                  The playbook will automatically construct the correct URL:
                  {{ tensorrt_final_url }}

                  Or download manually from: https://developer.nvidia.com/tensorrt
              when: available_trt_version.stdout == ''

            - name: (~70%) Set TensorRT package version from network repo
              set_fact:
                trt_pkg_version: "{{ available_trt_version.stdout }}"

            - name: (~70%) Install TensorRT packages with specific version from network repo
              apt:
                name:
                  - "tensorrt-dev={{ trt_pkg_version }}"
                  - "tensorrt-libs={{ trt_pkg_version }}"
                  - "libnvinfer10={{ trt_pkg_version }}"
                  - "libnvinfer-dev={{ trt_pkg_version }}"
                  - "libnvinfer-headers-dev={{ trt_pkg_version }}"
                  - "libnvinfer-plugin10={{ trt_pkg_version }}"
                  - "libnvonnxparsers10={{ trt_pkg_version }}"
                  - "python3-libnvinfer={{ trt_pkg_version }}"
                  - "python3-libnvinfer-dev={{ trt_pkg_version }}"
                state: present
                allow_downgrades: yes
              register: trt_install

        - name: (~70%) Hold TensorRT packages to prevent upgrades
          dpkg_selections:
            name: "{{ item }}"
            selection: hold
          loop:
            - tensorrt-dev
            - tensorrt-libs
            - libnvinfer10
            - libnvinfer-dev
            - libnvinfer-headers-dev
            - libnvinfer-plugin10
            - libnvonnxparsers10
            - python3-libnvinfer
            - python3-libnvinfer-dev

        - name: (~70%) Verify packages are held
          shell: dpkg --get-selections | grep -E "(tensorrt|libnvinfer)" | grep hold
          register: held_packages
          changed_when: false
          failed_when: held_packages.rc != 0

        - name: (~70%) Verify installed TensorRT version
          shell: dpkg -l | grep -E "(tensorrt|libnvinfer)" | grep -v "^rc"
          register: trt_ver
          changed_when: false

        - shell: |
            echo "{{ trt_ver.stdout }}" >> {{ log_file }}
            echo "" >> {{ log_file }}
            echo "Packages held (will NOT be upgraded by apt):" >> {{ log_file }}
            echo "{{ held_packages.stdout }}" >> {{ log_file }}

        - name: (~70%) Determine which method was used
          set_fact:
            trt_method_used: "{{ 'Local Repository' if (tensorrt_download is defined and tensorrt_download is succeeded) else 'Network Repository' }}"

        - debug:
            msg: |
              âœ… TensorRT {{ tensorrt_version_full }} installed and pinned
              Installation method: {{ trt_method_used }}
              {% if trt_method_used == 'Local Repository' %}
              Local repo URL: {{ tensorrt_final_url }}
              {% endif %}

              Held packages (protected from apt upgrade):
              {{ held_packages.stdout_lines }}

    # ==========================================================
    # 13. UNATTENDED-UPGRADES PROTECTION
    # ==========================================================
    - name: (~70%) Create unattended-upgrades GPU stack blacklist
      copy:
        dest: /etc/apt/apt.conf.d/51nvidia-blacklist
        mode: '0644'
        content: |
          // Prevent automatic upgrades of GPU stack packages
          // This ensures the frozen NVIDIA driver + CUDA + TensorRT versions remain stable
          Unattended-Upgrade::Package-Blacklist {
              "nvidia-driver-*";
              "nvidia-utils-*";
              "libnvidia-*";
              "nvidia-kernel-*";
              "nvidia-dkms-*";
              "cuda-*";
              "libcu*";
              "tensorrt-*";
              "libnvinfer*";
              "libnvonnxparsers*";
          };

    - debug:
        msg: "ðŸ›¡ï¸ Unattended-upgrades GPU stack blacklist created"

    # ==========================================================
    # 14. APT PREFERENCES (PIN-PRIORITY 1001)
    # ==========================================================
    - name: (~70%) Create APT preferences for GPU stack pinning
      copy:
        dest: /etc/apt/preferences.d/99-gpu-stack-pinning
        mode: '0644'
        content: |
          # Pin NVIDIA Driver {{ nvidia_driver_version_full }} - Highest Priority
          Package: nvidia-driver-{{ nvidia_driver_version }}
          Pin: version {{ nvidia_driver_version_full }}*
          Pin-Priority: 1001

          Package: nvidia-*-{{ nvidia_driver_version }}
          Pin: version *
          Pin-Priority: 1001

          # Pin CUDA Toolkit {{ cuda_version_full }}
          Package: cuda-toolkit-{{ cuda_version }}
          Pin: version *
          Pin-Priority: 1001

          Package: cuda-*-{{ cuda_version }}
          Pin: version *
          Pin-Priority: 1001

          Package: libcu*
          Pin: version *{{ cuda_version_full }}*
          Pin-Priority: 1001

          # Pin TensorRT {{ tensorrt_version_full }}
          Package: tensorrt-*
          Pin: version *{{ tensorrt_version_full }}*
          Pin-Priority: 1001

          Package: libnvinfer*
          Pin: version *
          Pin-Priority: 1001

          # Prevent newer CUDA versions from being installed
          Package: cuda-toolkit-14-*
          Pin: version *
          Pin-Priority: -1

          Package: cuda-toolkit-15-*
          Pin: version *
          Pin-Priority: -1

    - debug:
        msg: "ðŸ“Œ APT preferences pinning created (Pin-Priority 1001)"

    # ==========================================================
    # 15. REPOSITORY CLEANUP
    # ==========================================================
    - name: (~70%) Clean up old local repositories
      shell: |
        # Keep only the most recent TensorRT local repo
        find /var -maxdepth 1 -mindepth 1 -type d -name 'nv-tensorrt-local-repo-*' 2>/dev/null | sort -r | tail -n +2 | xargs -r rm -rf 2>/dev/null || true
        # Keep only the most recent CUDA local repo
        find /var -maxdepth 1 -mindepth 1 -type d -name 'cuda-repo-ubuntu2404-*-local' 2>/dev/null | sort -r | tail -n +2 | xargs -r rm -rf 2>/dev/null || true
        # Keep only the most recent NVIDIA driver local repo
        find /var -maxdepth 1 -mindepth 1 -type d -name 'nvidia-driver-local-repo-*' 2>/dev/null | sort -r | tail -n +2 | xargs -r rm -rf 2>/dev/null || true
      failed_when: false
      changed_when: false

    - debug:
        msg: "ðŸ§¹ Old local repositories cleaned up"

    # ==========================================================
    # 15. DOCKER + NVIDIA RUNTIME
    # ==========================================================
    - name: (~70%) Install Docker and NVIDIA container runtime
      block:
        - name: (~75%) Install Docker prerequisites
          apt:
            name:
              - apt-transport-https
              - ca-certificates
              - curl
              - gnupg
              - lsb-release
            state: present

        - name: (~75%) Create keyrings directory
          file:
            path: /etc/apt/keyrings
            state: directory
            mode: '0755'

        - name: (~75%) Download Docker GPG key directly to keyrings
          shell: curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
          args:
            creates: /etc/apt/keyrings/docker.asc

        - name: (~75%) Set permissions on Docker GPG key
          file:
            path: /etc/apt/keyrings/docker.asc
            mode: '0644'

        - name: (~75%) Add Docker repository with dynamic architecture and codename
          shell: |
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
            $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
            tee /etc/apt/sources.list.d/docker.list > /dev/null
          args:
            creates: /etc/apt/sources.list.d/docker.list

        - name: (~75%) Update apt cache for Docker
          apt:
            update_cache: yes

        - name: (~75%) Install Docker packages
          apt:
            name:
              - docker-ce
              - docker-ce-cli
              - containerd.io
              - docker-buildx-plugin
              - docker-compose-plugin
            state: present

        - name: (~75%) Add user to docker group
          user:
            name: "{{ ssh_user }}"
            groups: docker
            append: yes

        - name: (~75%) Create keyrings directory for NVIDIA Container Toolkit
          file:
            path: /usr/share/keyrings
            state: directory
            mode: '0755'

        - name: (~75%) Download and install NVIDIA Container Toolkit GPG key
          shell: |
            curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | \
            gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg
          args:
            creates: /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg

        - name: (~75%) Add NVIDIA Container Toolkit repository
          shell: |
            curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \
            sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \
            tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
          args:
            creates: /etc/apt/sources.list.d/nvidia-container-toolkit.list

        - name: (~75%) Update apt cache for NVIDIA Container Toolkit
          apt:
            update_cache: yes

        - name: (~80%) Install NVIDIA Container Toolkit
          apt:
            name: nvidia-container-toolkit
            state: present

        - name: (~80%) Configure Docker runtime using nvidia-ctk
          command: nvidia-ctk runtime configure --runtime=docker
          register: nvidia_ctk_config
          changed_when: nvidia_ctk_config.rc == 0
          notify: restart docker

        - name: (~80%) Start and enable Docker service
          systemd:
            name: docker
            state: started
            enabled: yes

        - shell: echo "âœ… Docker and NVIDIA Container Toolkit installed." >> {{ log_file }}
        - debug: msg="âœ… Docker and NVIDIA Container Toolkit installed."
      rescue:
        - debug: msg="âš ï¸ Docker installation failed."
        - shell: echo "âš ï¸ Docker installation failed." >> {{ log_file }}
    
    # ==========================================================
    # 14. PYTHON & DEV TOOLS
    # ==========================================================
    - name: (~80%) Install Python and dev tools
      apt:
        name:
          - python3
          - python3-pip
          - python3-venv
          - python3.12-venv
          - python3-dev
        state: present
      register: python_install
    
    - shell: python3 --version
      register: pyver
    
    - debug: msg="âœ… Python {{ pyver.stdout }} installed."

    # ==========================================================
    # 14b. HEALTHCHECKS.IO PROMPT (late, near completion)
    # ==========================================================
    - name: (~80%) Prompt for Healthchecks.io URL
      pause:
        prompt: |

          ============================================================
          HEALTHCHECKS.IO SETUP
          ============================================================

          Please create a healthcheck at https://healthchecks.io

          Steps:
          1. Go to https://healthchecks.io and create a free account
          2. Create a new check with name: "{{ ansible_hostname }}"
          3. Set the period to 10 minutes (allows 5 min pings + buffer)
          4. Copy the ping URL (looks like: https://hc-ping.com/YOUR-UUID-HERE)

          Paste your Healthchecks.io ping URL (or press Enter to skip)
      register: healthchecks_prompt
      when: healthchecks_url is not defined

    - name: (~80%) Set healthchecks URL from user input or default
      set_fact:
        healthchecks_url: "{{ healthchecks_prompt.user_input if (healthchecks_prompt.user_input | default('') | length > 0) else 'SKIPPED' }}"
      when: healthchecks_url is not defined

    - name: (~80%) Set healthchecks URL if already defined
      set_fact:
        healthchecks_url: "{{ healthchecks_url }}"
      when: healthchecks_url is defined

    # ==========================================================
    # 15. HEALTHCHECKS.IO SERVICE
    # ==========================================================
    - name: (~80%) Setup Healthchecks.io service
      block:
        - name: (~80%) Create healthcheck ping script
          copy:
            dest: /usr/local/bin/healthcheck-ping.sh
            mode: '0755'
            content: |
              #!/bin/bash
              set -e
              curl -fsS -m 10 --retry 5 -o /dev/null "{{ healthchecks_url }}" || echo "Healthcheck failed $(date)"
        - name: (~80%) Create systemd service for healthcheck
          copy:
            dest: /etc/systemd/system/healthcheck.service
            mode: '0644'
            content: |
              [Unit]
              Description=Healthchecks.io ping

              [Service]
              Type=oneshot
              ExecStart=/usr/local/bin/healthcheck-ping.sh
        - name: (~80%) Create systemd timer for healthcheck (every 5 minutes)
          copy:
            dest: /etc/systemd/system/healthcheck.timer
            mode: '0644'
            content: |
              [Unit]
              Description=Run healthcheck ping every 5 minutes

              [Timer]
              OnBootSec=1min
              OnUnitActiveSec=5min
              AccuracySec=30s

              [Install]
              WantedBy=timers.target
          notify: reload systemd
        - name: (~85%) Enable and start healthcheck timer
          systemd: { name: healthcheck.timer, enabled: yes, state: started }
          register: healthcheck_timer

        - debug: msg="âœ… Healthcheck service active (ping every 5 min) - {{ healthchecks_url }}"
      when: healthchecks_url != 'SKIPPED'

    - name: (~85%) Warn healthcheck skipped
      debug:
        msg: "âš ï¸  Healthcheck service skipped (no URL provided)."
      when: healthchecks_url == 'SKIPPED'

    # ==========================================================
    # 16. AUTO_TEST PYTHON ENVIRONMENT SETUP
    # ==========================================================
    - name: (~85%) Create code directory structure
      file:
        path: "{{ user_home }}/code/auto_test"
        state: directory
        mode: '0755'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"

    - name: (~85%) Create Python 3.12 virtual environment
      become: yes
      become_user: "{{ ssh_user }}"
      command: python3.12 -m venv "{{ user_home }}/code/auto_test/venv"
      args:
        creates: "{{ user_home }}/code/auto_test/venv"

    - name: (~85%) Upgrade pip, setuptools, and wheel in venv
      become: yes
      become_user: "{{ ssh_user }}"
      shell: |
        source {{ user_home }}/code/auto_test/venv/bin/activate
        pip install --upgrade pip setuptools wheel
      args:
        executable: /bin/bash

    - name: (~85%) Create activation helper script
      copy:
        dest: "{{ user_home }}/code/auto_test/activate.sh"
        mode: '0755'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"
        content: |
          #!/bin/bash
          source {{ user_home }}/code/auto_test/venv/bin/activate
          echo "Virtual environment activated!"
          echo "Python: $(which python3)"
          python3 << 'EOF'
          import torch
          print(f"PyTorch {torch.__version__} - CUDA available: {torch.cuda.is_available()}")
          if torch.cuda.is_available():
              print(f"GPU: {torch.cuda.get_device_name(0)}")
          EOF

    - debug:
        msg: |
          âœ… Virtual environment created at ~/code/auto_test

          âš ï¸  Reboot required to load NVIDIA driver
          âš ï¸  After reboot, run: ansible-playbook post-reboot-verify.yml -K
          This will install PyTorch, ultralytics, TensorRT, and verify CUDA

    # ==========================================================
    # 17. REBOOT NOTIFICATION
    # ==========================================================
    - name: (~85%) Check if reboot is required
      stat:
        path: /var/run/reboot-required
      register: reboot_required_file

    - name: (~85%) Set reboot requirement fact
      set_fact:
        needs_reboot: "{{ reboot_required_file.stat.exists or nvidia_driver_install.changed }}"

    - name: (~85%) Display reboot notification
      debug:
        msg: |
          âš ï¸  ============================================
          âš ï¸  REBOOT REQUIRED
          âš ï¸  ============================================
          NVIDIA driver and/or kernel modules have been updated.
          The system needs to be rebooted to activate all changes.

          Please reboot when convenient:
            sudo reboot
      when: needs_reboot

    # ==========================================================
    # 17. GIT SETUP (SSH default, standard ed25519 key â€“ prompted at end of run)
    # ==========================================================
    - name: (~85%) Prompt for Git user name
      pause:
        prompt: "Git user.name for commits on this machine"
      register: git_name_prompt
      when: git_user_name is not defined

    - name: (~85%) Set git_user_name from prompt
      set_fact:
        git_user_name: "{{ git_name_prompt.user_input | default('', true) | trim }}"
      when: git_user_name is not defined

    - name: (~90%) Prompt for Git user email
      pause:
        prompt: "Git user.email for commits on this machine"
      register: git_email_prompt
      when: git_user_email is not defined

    - name: (~90%) Set git_user_email from prompt
      set_fact:
        git_user_email: "{{ git_email_prompt.user_input | default('', true) | trim }}"
      when: git_user_email is not defined

    - name: (~90%) Set git user.name and user.email
      command: 'git config --global {{ item.key | quote }} {{ item.value | quote }}'
      loop:
        - { key: "user.name", value: "{{ git_user_name | default('') }}" }
        - { key: "user.email", value: "{{ git_user_email | default('') }}" }
      when: (git_user_name | default('')) | length > 0 and (git_user_email | default('')) | length > 0
      become_user: "{{ ssh_user }}"
      changed_when: true

    - name: (~90%) Set Git to use SSH instead of HTTPS for GitHub
      command: git config --global url."git@github.com:".insteadOf "https://github.com/"
      become_user: "{{ ssh_user }}"
      changed_when: true

    - name: (~90%) Ensure .ssh exists for SSH key
      file:
        path: "{{ user_home }}/.ssh"
        state: directory
        mode: '0700'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"

    - name: (~90%) Generate standard SSH key (ed25519)
      command: >
        ssh-keygen -t ed25519 -C "{{ ssh_user }}@{{ ansible_hostname }}"
        -f {{ user_home }}/.ssh/id_ed25519 -N ""
      args:
        creates: "{{ user_home }}/.ssh/id_ed25519"
      become_user: "{{ ssh_user }}"

    - name: (~90%) Check whether SSH config exists
      stat:
        path: "{{ user_home }}/.ssh/config"
      register: ssh_config_stat

    - name: (~90%) Remove legacy GitHub-specific SSH config block
      blockinfile:
        path: "{{ user_home }}/.ssh/config"
        marker: "# {mark} ANSIBLE MANAGED BLOCK - GitHub key"
        state: absent
      when: ssh_config_stat.stat.exists | default(false)
      become_user: "{{ ssh_user }}"

    - name: (~90%) Read GitHub SSH public key
      slurp:
        src: "{{ user_home }}/.ssh/id_ed25519.pub"
      register: github_key_content

    - name: (~90%) Display GitHub SSH public key for user to add
      debug:
        msg: |
          ========== ADD THIS KEY TO GITHUB ==========
          Settings â†’ SSH and GPG keys â†’ New SSH key
          Paste the key below, then press Enter in the playbook to continue.
          ----------
          {{ github_key_content.content | b64decode | trim }}
          ----------
      when: github_key_content.content is defined

    - name: (~90%) Pause for user to add key to GitHub
      pause:
        prompt: "Add the key above to GitHub, then press Enter to continue"
      when: github_key_content.content is defined

    # ==========================================================
    # 17b. TOUCHSCREEN BASE SETUP (late in run, before network info)
    # ==========================================================
    - name: (~95%) Detect eGalax touchscreen via lsusb
      shell: lsusb | grep -i -E 'egalax|0eef:'
      register: touchscreen_lsusb_detect
      changed_when: false
      failed_when: false

    - name: (~95%) Show touchscreen detected confirmation
      debug:
        msg: "âœ… Touchscreen detected: {{ touchscreen_lsusb_detect.stdout | trim }}"
      when: touchscreen_lsusb_detect.rc == 0

    - name: (~95%) Prompt to install touchscreen support (device not found in lsusb)
      pause:
        prompt: |

          ============================================================
          TOUCHSCREEN NOT DETECTED
          ============================================================
          No eGalax touchscreen found in lsusb output.
          All machines should have a touchscreen â€” check USB connection.

          Install touchscreen support packages anyway? (y/N)
      register: touchscreen_prompt
      when: touchscreen_lsusb_detect.rc != 0

    - name: (~95%) Set touchscreen install flag
      set_fact:
        touchscreen_install: "{{ touchscreen_lsusb_detect.rc == 0 or (touchscreen_prompt.user_input | default('n') | lower == 'y') }}"

    - name: (~95%) Install touchscreen support packages
      apt:
        name:
          - xserver-xorg-input-libinput
          - xserver-xorg-input-evdev
          - xserver-xorg-input-multitouch
          - xinput-calibrator
        state: present
      when: touchscreen_install | bool

    - name: (~95%) Ensure Xorg config directory exists for touchscreen config
      file:
        path: /etc/X11/xorg.conf.d
        state: directory
        mode: '0755'
      when: touchscreen_install | bool

    - name: (~95%) Write touchscreen Xorg config (eGalax defaults)
      copy:
        dest: /etc/X11/xorg.conf.d/99-touchscreen.conf
        mode: '0644'
        content: |
          Section "InputClass"
              Identifier "Touchscreen"
              MatchProduct "eGalax Inc. USB TouchController"
              MatchDevicePath "/dev/input/event*"
              Driver "evdev"
              Option "Calibration" "0 4095 0 4095"
              Option "InvertX" "0"
              Option "InvertY" "0"
          EndSection
      when: touchscreen_install | bool

    # ==========================================================
    # 17c. NETWORK INFO (for user to record, late in run)
    # ==========================================================
    - name: (~95%) Gather network interface info for display
      shell: |
        echo "========== NETWORK INFO (record MACs and IPs) =========="
        ip -br addr show | while read iface state rest; do
          [ "$iface" = "lo" ] && continue
          mac=$(ip link show "$iface" 2>/dev/null | grep 'link/ether' | awk '{print $2}')
          [ -z "$mac" ] && mac="N/A"
          echo "  $iface: state=$state MAC=$mac"
          ip -4 addr show "$iface" 2>/dev/null | grep inet | awk '{print "    IP: "$2}'
        done
        echo "========================================================="
      register: network_info_display
      changed_when: false

    - name: (~95%) Display network info to user
      debug:
        msg: "{{ network_info_display.stdout_lines }}"

    - name: (~95%) Log late network info display
      shell: "echo 'Network info (MACs, IPs) displayed near completion' >> {{ log_file }}"
      changed_when: false

    # ==========================================================
    # 18. FINAL MESSAGE
    # ==========================================================
    - name: (~95%) Write final summary to log
      shell: |
        echo "===================================================================" >> {{ log_file }}
        echo "âœ… Setup complete!" >> {{ log_file }}
        echo "- NVIDIA driver {{ nvidia_driver_version }}, CUDA {{ cuda_version_full }}" >> {{ log_file }}
        echo "- TensorRT installed" >> {{ log_file }}
        echo "- SSH on port {{ ssh_port }} (key-only)" >> {{ log_file }}
        echo "- Docker + NVIDIA runtime ready" >> {{ log_file }}
        echo "- Tailscale and RealVNC installed" >> {{ log_file }}
        echo "- Git configured (SSH for GitHub)" >> {{ log_file }}
        echo "- Touchscreen base packages/config installed (if applicable)" >> {{ log_file }}
        {% if healthchecks_url != 'SKIPPED' %}
        echo "- Healthcheck active (every 5 min): {{ healthchecks_url }}" >> {{ log_file }}
        {% else %}
        echo "- Healthcheck skipped (no URL provided)" >> {{ log_file }}
        {% endif %}
        echo "- Scheduled reboots at 6 and 18 (root cron installed by playbook)" >> {{ log_file }}
        echo "- Auto test environment: ~/code/auto_test (Python 3.12 venv)" >> {{ log_file }}
        echo "===================================================================" >> {{ log_file }}
        echo "Completed at: $(date)" >> {{ log_file }}
        echo "Log file: {{ log_file }}" >> {{ log_file }}
        {% if needs_reboot %}
        echo "" >> {{ log_file }}
        echo "âš ï¸  Please reboot the system: sudo reboot" >> {{ log_file }}
        {% endif %}

    - debug:
        msg: |
          ===================================================================
          âœ… Setup complete!
          - NVIDIA driver {{ nvidia_driver_version }}, CUDA {{ cuda_version_full }}
          - TensorRT installed
          - SSH on port {{ ssh_port }} (key-only)
          - Docker + NVIDIA runtime ready
          - Tailscale and RealVNC installed
          - Git configured (SSH for GitHub)
          - Touchscreen base packages/config installed (if applicable)
          {% if healthchecks_url != 'SKIPPED' %}
          - Healthcheck active (every 5 min): {{ healthchecks_url }}
          {% else %}
          - Healthcheck skipped (no URL provided)
          {% endif %}
          - Scheduled reboots at 6 and 18 (root cron installed by playbook)
          - Auto test environment: ~/code/auto_test (Python 3.12 venv)

          Activate venv: source ~/code/auto_test/activate.sh
          Log file saved to: {{ log_file }}
          {% if needs_reboot %}

          âš ï¸  Please reboot the system: sudo reboot
          {% endif %}
          ===================================================================

  handlers:
    - name: (~100%) restart sshd
      listen: restart sshd
      systemd: { name: sshd, state: restarted }
    - name: (~100%) restart docker
      listen: restart docker
      systemd: { name: docker, state: restarted }
    - name: (~100%) restart gdm3
      listen: restart gdm3
      systemd: { name: gdm3, state: restarted }
      when: gdm3_config.stat.exists | default(false)
    - name: (~100%) restart lightdm
      listen: restart lightdm
      systemd: { name: lightdm, state: restarted }
      when: lightdm_config.stat.exists | default(false)
    - name: (~100%) update ldconfig
      listen: update ldconfig
      command: ldconfig
    - name: (~100%) reload systemd
      listen: reload systemd
      systemd: { daemon_reload: yes }
