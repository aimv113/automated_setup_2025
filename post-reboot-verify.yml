---
- name: Post-Reboot Verification
  hosts: localhost
  connection: local
  become: yes

  vars_files:
    - vars/common.yml

  vars:
    log_file: "/var/log/ansible-post-reboot-verify-{{ ansible_date_time.iso8601_basic_short }}.log"

  tasks:

    - name: (~0%) Validate running as root (become check)
      command: id -u
      register: become_uid_check
      changed_when: false

    - name: (~0%) Fail with clear message if not root
      fail:
        msg: |
          This playbook must run with sudo privileges.
          Run: ansible-playbook post-reboot-verify.yml -K
          Or ensure your sudo timestamp is active (e.g. run 'sudo -v' first).
      when: become_uid_check.stdout | trim != "0"

    # ==========================================================
    # 1. LOG INITIALIZATION
    # ==========================================================
    - name: (~5%) Initialize verification log file
      shell: |
        echo "===========================================================" > {{ log_file }}
        echo "POST-REBOOT VERIFICATION - $(date)" >> {{ log_file }}
        echo "===========================================================" >> {{ log_file }}
        echo "" >> {{ log_file }}

    - debug:
        msg: "Starting post-reboot verification - Log: {{ log_file }}"

    # ==========================================================
    # 2. VERIFY NVIDIA DRIVER
    # ==========================================================
    - name: (~5%) Check NVIDIA driver is loaded
      shell: nvidia-smi
      register: nvidia_smi
      failed_when: nvidia_smi.rc != 0

    - debug:
        msg: "✅ NVIDIA driver loaded"

    # ==========================================================
    # 3. VERIFY CUDA TOOLKIT
    # ==========================================================
    - name: (~10%) Check CUDA version
      shell: /usr/local/cuda-{{ cuda_version_full }}/bin/nvcc --version
      register: nvcc_version
      failed_when: nvcc_version.rc != 0

    - debug:
        msg: "✅ CUDA toolkit available"

    # ==========================================================
    # 4. VERIFY DOCKER + NVIDIA RUNTIME
    # ==========================================================
    - name: (~10%) Test Docker with NVIDIA runtime
      shell: docker run --rm --gpus all nvidia/cuda:{{ cuda_version_full_numeric }}-base-ubuntu{{ ansible_distribution_version }} nvidia-smi
      register: docker_nvidia
      failed_when: docker_nvidia.rc != 0

    - debug:
        msg: "✅ Docker can access GPU"

    # ==========================================================
    # 5. INSTALL ML PACKAGES WITH CUDA SUPPORT
    # ==========================================================
    - name: (~10%) Install PyTorch with CUDA 13.0 support
      become: yes
      become_user: "{{ ssh_user }}"
      shell: |
        source {{ user_home }}/code/auto_test/venv/bin/activate
        pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu130
      args:
        executable: /bin/bash
      register: torch_install

    - name: (~15%) Install ultralytics, tensorrt, and onnxruntime-gpu
      become: yes
      become_user: "{{ ssh_user }}"
      shell: |
        source {{ user_home }}/code/auto_test/venv/bin/activate
        pip install ultralytics nvidia-tensorrt onnxruntime-gpu
      args:
        executable: /bin/bash
      register: ml_packages_install

    - debug:
        msg: "✅ ML packages installed with CUDA support"

    # ==========================================================
    # 6. VERIFY PYTORCH CUDA SUPPORT
    # ==========================================================
    - name: (~15%) Verify CUDA is available to PyTorch
      become: yes
      become_user: "{{ ssh_user }}"
      shell: |
        source {{ user_home }}/code/auto_test/venv/bin/activate
        python3 << 'EOF'
        import torch
        print(f"PyTorch version: {torch.__version__}")
        print(f"CUDA available: {torch.cuda.is_available()}")
        if torch.cuda.is_available():
            print(f"CUDA version: {torch.version.cuda}")
            print(f"GPU count: {torch.cuda.device_count()}")
            print(f"GPU name: {torch.cuda.get_device_name(0)}")
        else:
            print("WARNING: CUDA is not available to PyTorch!")
        EOF
      args:
        executable: /bin/bash
      register: cuda_verification
      failed_when: "'CUDA available: False' in cuda_verification.stdout"

    - debug:
        msg: "{{ cuda_verification.stdout_lines }}"

    # ==========================================================
    # 7. VERIFY TENSORRT
    # ==========================================================
    - name: (~15%) Check TensorRT installation
      shell: dpkg -l | grep tensorrt
      register: tensorrt_check
      failed_when: tensorrt_check.rc != 0

    - debug:
        msg: "✅ TensorRT packages installed"

    # ==========================================================
    # 7. DATA FOLDERS (videos and jpgs for app)
    # ==========================================================
    - name: (~20%) Ensure app data base path exists
      file:
        path: "{{ app_data_path }}"
        state: directory
        mode: '0755'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"

    - name: (~20%) Create data/jpg/video/ad_hoc structure at app_data_path
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
        owner: "{{ ssh_user }}"
        group: "{{ ssh_user }}"
      loop:
        - "{{ app_data_path }}"
        - "{{ app_data_path }}/jpg"
        - "{{ app_data_path }}/video"
        - "{{ app_data_path }}/jpg/no_hook"
        - "{{ app_data_path }}/jpg/no_overlay"
        - "{{ app_data_path }}/ad_hoc"
        - "{{ app_data_path }}/ad_hoc/jpg"
        - "{{ app_data_path }}/ad_hoc/video"

    # ==========================================================
    # 8. NETWORKING (NetworkManager + netplan: DHCP + camera static + optional WiFi)
    # Netplan is configured with renderer: NetworkManager; on Ubuntu Server
    # NetworkManager is not installed by default (systemd-networkd is), so we install it.
    # ==========================================================
    - name: (~25%) Ensure networking tools are installed (NetworkManager, rfkill, iw)
      apt:
        name:
          - network-manager
          - rfkill
          - iw
        state: present

    - name: (~25%) Ensure NetworkManager is enabled and started
      systemd:
        name: NetworkManager
        state: started
        enabled: true

    - name: (~25%) Write netplan 01-network-manager.yaml (renderer NetworkManager)
      template:
        src: 01-network-manager.yaml
        dest: /etc/netplan/01-network-manager.yaml
        mode: "0600"

    - name: (~30%) Get default route interface (has internet)
      shell: ip route show default 2>/dev/null | awk '{print $5}' | head -1
      register: default_route_iface
      changed_when: false
      failed_when: false

    - name: (~30%) List physical ethernet interfaces (exclude wireless/virtual tunnel/overlay)
      shell: |
        for p in /sys/class/net/*; do
          iface="$(basename "$p")"
          [ "$iface" = "lo" ] && continue
          [ -d "$p/wireless" ] && continue
          # Skip known virtual/tunnel/overlay interfaces that are not camera NIC candidates.
          case "$iface" in
            zt*|tailscale*|docker*|br-*|virbr*|veth*|tun*|tap*|wg*|ppp*)
              continue
              ;;
          esac
          # Require a backing device to avoid virtual interfaces (e.g., ZeroTier/Tailscale).
          [ -e "$p/device" ] || continue
          [ -f "$p/type" ] && [ "$(cat "$p/type")" != "1" ] && continue
          echo "$iface"
        done
      register: ethernet_ifaces_raw
      changed_when: false

    - name: (~35%) Bring up ethernet interfaces before link detection (non-fatal)
      shell: |
        for iface in {{ ethernet_ifaces_raw.stdout_lines | default([]) | join(' ') }}; do
          [ -n "$iface" ] && ip link set "$iface" up >/dev/null 2>&1 || true
        done
      changed_when: false
      failed_when: false
      when: ethernet_ifaces_raw.stdout_lines | default([]) | length > 0

    - name: (~35%) List connected ethernet interfaces (carrier up or operstate up)
      shell: |
        for iface in {{ ethernet_ifaces_raw.stdout_lines | default([]) | join(' ') }}; do
          [ -z "$iface" ] && continue
          carrier=""
          state=""
          [ -f "/sys/class/net/$iface/carrier" ] && carrier="$(cat /sys/class/net/$iface/carrier 2>/dev/null || true)"
          [ -f "/sys/class/net/$iface/operstate" ] && state="$(cat /sys/class/net/$iface/operstate 2>/dev/null || true)"
          if [ "$carrier" = "1" ] || [ "$state" = "up" ]; then
            echo "$iface"
          fi
        done
      register: connected_ethernet_raw
      changed_when: false
      failed_when: false
      when: ethernet_ifaces_raw.stdout_lines | default([]) | length > 0

    - name: (~35%) Set internet interface (default route or single ethernet fallback)
      set_fact:
        internet_interface: "{{ default_route_iface.stdout if default_route_iface.stdout else (connected_ethernet_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list | first if (connected_ethernet_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list | length == 1) else ((ethernet_ifaces_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list | first) if (ethernet_ifaces_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list | length == 1) else '')) }}"

    - name: (~40%) Build list of camera interfaces (connected ethernet, no IPv4; exclude internet interface)
      shell: |
        default_if="{{ default_route_iface.stdout }}"
        internet_if="{{ internet_interface | default('') }}"
        for iface in {{ connected_ethernet_raw.stdout_lines | default([]) | join(' ') }}; do
          [ -z "$iface" ] && continue
          [ "$iface" = "$default_if" ] && continue
          [ -n "$internet_if" ] && [ "$iface" = "$internet_if" ] && continue
          # Interface with no IPv4 address = camera NIC (ping -I is unreliable when the
          # interface has no IP — the kernel borrows another interface's address and ping
          # can succeed even though this interface has no internet connectivity).
          has_ipv4=$(ip -4 addr show "$iface" 2>/dev/null | grep -c 'inet ' || true)
          if [ "$has_ipv4" = "0" ]; then
            echo "$iface"
          fi
        done
      register: camera_ifaces_raw
      changed_when: false
      failed_when: false

    - name: (~40%) Set camera_interfaces fact
      set_fact:
        camera_interfaces: "{{ camera_ifaces_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list }}"

    - name: (~40%) Build camera static config (name and address per interface)
      set_fact:
        camera_static_config: "{{ camera_static_config | default([]) + [{'name': item, 'address': '192.168.1.' ~ (camera_static_start + (camera_static_config | default([]) | length)) ~ '/24'}] }}"
      loop: "{{ camera_interfaces }}"
      when: camera_interfaces | length > 0
      loop_control:
        label: "{{ item }}"

    - name: (~45%) Warn when multiple connected ethernet interfaces but no default route (skipping netplan)
      debug:
        msg: "No default route and multiple connected ethernet interfaces; skipping netplan. Fix network or set default route and re-run."
      when: (default_route_iface.stdout | length == 0) and (connected_ethernet_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list | length > 1)

    - name: (~45%) Set machine_netplan_ethernets (internet DHCP + camera static)
      set_fact:
        machine_netplan_ethernets: "{{ ([{'name': internet_interface, 'dhcp4': True}] if internet_interface else []) + (camera_static_config | default([]) | map('combine', {'dhcp4': False}) | list) }}"
      when: (default_route_iface.stdout | length > 0) or (connected_ethernet_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list | length == 1) or (ethernet_ifaces_raw.stdout_lines | default([]) | select('match', '^[a-zA-Z]') | list | length == 1)

    - name: (~50%) Detect wireless interface when WiFi SSID is set (tolerates no WLAN)
      shell: |
        for i in /sys/class/net/*/wireless; do
          [ -d "$i" ] && echo "${i%/wireless}" | sed 's|.*/net/||' && break
        done
        true
      register: wifi_interface_out
      changed_when: false
      failed_when: false
      when: machine_wifi_ssid is defined and machine_wifi_ssid | length > 0

    - name: (~50%) Set machine_wifi_interface from detected WiFi device
      set_fact:
        machine_wifi_interface: "{{ wifi_interface_out.stdout }}"
      when: machine_wifi_ssid is defined and machine_wifi_ssid | length > 0 and wifi_interface_out.stdout is defined and wifi_interface_out.stdout | length > 0

    - name: (~50%) Pause when no WiFi adapter (setup incomplete) — continue or abort
      pause:
        prompt: |
          No WiFi adapter detected. This machine cannot connect to "{{ machine_wifi_ssid }}".
          Setup will be incomplete (WiFi will not be configured).
          Press Enter to continue anyway, or Ctrl+C to abort.
        echo: true
      when: machine_wifi_ssid is defined and machine_wifi_ssid | length > 0 and (machine_wifi_interface is not defined or machine_wifi_interface | length == 0)

    - name: (~55%) Log warning when WiFi skipped (no adapter)
      debug:
        msg: "WiFi skipped: no wireless interface; machine cannot connect to {{ machine_wifi_ssid }}. Setup incomplete."
      when: machine_wifi_ssid is defined and machine_wifi_ssid | length > 0 and (machine_wifi_interface is not defined or machine_wifi_interface | length == 0)

    - name: (~55%) Set apply_machine_network flag (ethernets and/or WiFi)
      set_fact:
        apply_machine_network: "{{ (machine_netplan_ethernets is defined and machine_netplan_ethernets | length > 0) or (machine_wifi_ssid is defined and machine_wifi_ssid | length > 0 and (machine_wifi_interface is defined and machine_wifi_interface | length > 0)) }}"

    - name: (~60%) Stat 50-cloud-init.yaml
      stat:
        path: /etc/netplan/50-cloud-init.yaml
      register: cloud_init_netplan_stat
      when: machine_network_remove_cloud_init and apply_machine_network | default(false) | bool

    - name: (~60%) Backup 50-cloud-init.yaml if present
      copy:
        src: /etc/netplan/50-cloud-init.yaml
        dest: /etc/netplan/50-cloud-init.yaml.bak
        remote_src: yes
      when: machine_network_remove_cloud_init and apply_machine_network | default(false) | bool and (cloud_init_netplan_stat is defined and cloud_init_netplan_stat.stat.exists | default(false))

    - name: (~60%) Remove 50-cloud-init.yaml
      file:
        path: /etc/netplan/50-cloud-init.yaml
        state: absent
      when: machine_network_remove_cloud_init and apply_machine_network | default(false) | bool

    - name: (~65%) Write netplan 99-machine-network.yaml
      template:
        src: 99-machine-network.yaml.j2
        dest: /etc/netplan/99-machine-network.yaml
        mode: "0600"
      when: apply_machine_network | default(false) | bool

    - name: (~65%) Apply netplan (safe even if SSID absent)
      command: netplan generate && netplan apply

    - name: (~65%) Set WiFi device to managed by NetworkManager
      command: nmcli device set "{{ machine_wifi_interface }}" managed yes
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false
      changed_when: false

    - name: (~70%) Ensure WiFi is unblocked (non-fatal)
      command: rfkill unblock all
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false
      changed_when: false

    - name: (~70%) Ensure WiFi radio is enabled (non-fatal)
      command: nmcli radio wifi on
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false
      changed_when: false

    - name: (~75%) Bring WiFi link up (non-fatal)
      command: ip link set "{{ machine_wifi_interface }}" up
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false
      changed_when: false

    - name: (~75%) Remove existing WiFi profiles for SSID (non-fatal)
      shell: |
        for prof in "{{ machine_wifi_ssid }}-2.4GHz" "{{ machine_wifi_ssid }}-5GHz" "{{ machine_wifi_ssid }}"; do
          nmcli -t -f NAME connection show | grep -qx "$prof" && nmcli connection delete "$prof" || true
        done
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false
      changed_when: false

    - name: (~75%) Bring WiFi device up via NetworkManager (non-fatal)
      command: nmcli device connect "{{ machine_wifi_interface }}"
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false
      changed_when: false

    # WiFi: two NM profiles (2.4 + 5 GHz), autoconnect priority 2.4 > 5; open network (no auth).
    - name: (~80%) Create NM WiFi profile {{ machine_wifi_ssid }}-2.4GHz (2.4GHz preferred)
      command: >
        nmcli connection add type wifi ifname "{{ machine_wifi_interface }}" con-name "{{ machine_wifi_ssid }}-2.4GHz" ssid "{{ machine_wifi_ssid }}"
        wifi.band bg connection.autoconnect yes connection.autoconnect-priority 100
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      register: nm_add_24
      failed_when: false
      changed_when: nm_add_24.rc == 0

    - name: (~80%) Create NM WiFi profile {{ machine_wifi_ssid }}-5GHz (5GHz fallback)
      command: >
        nmcli connection add type wifi ifname "{{ machine_wifi_interface }}" con-name "{{ machine_wifi_ssid }}-5GHz" ssid "{{ machine_wifi_ssid }}"
        wifi.band a connection.autoconnect yes connection.autoconnect-priority 10
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      register: nm_add_5
      failed_when: false
      changed_when: nm_add_5.rc == 0

    - name: (~85%) Align NM profile {{ machine_wifi_ssid }}-2.4GHz (2.4GHz preferred; open network)
      command: >
        nmcli connection modify "{{ machine_wifi_ssid }}-2.4GHz"
        connection.interface-name "{{ machine_wifi_interface }}"
        wifi.band bg connection.autoconnect yes connection.autoconnect-priority 100
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false

    - name: (~85%) Align NM profile {{ machine_wifi_ssid }}-5GHz (5GHz fallback; open network)
      command: >
        nmcli connection modify "{{ machine_wifi_ssid }}-5GHz"
        connection.interface-name "{{ machine_wifi_interface }}"
        wifi.band a connection.autoconnect yes connection.autoconnect-priority 10
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false

    - name: (~85%) Set open-WiFi security mode for open network profiles
      command: >
        nmcli connection modify "{{ item }}"
        wifi-sec.key-mgmt none
      loop:
        - "{{ machine_wifi_ssid }}-2.4GHz"
        - "{{ machine_wifi_ssid }}-5GHz"
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false

    - name: (~90%) Connect to WiFi only if SSID is visible (non-fatal)
      shell: |
        nmcli dev wifi rescan >/dev/null 2>&1 || true
        nmcli -t -f SSID dev wifi list | grep -Fx "{{ machine_wifi_ssid }}" >/dev/null && (nmcli connection up "{{ machine_wifi_ssid }}-2.4GHz" || nmcli connection up "{{ machine_wifi_ssid }}-5GHz") || true
      when: >
        machine_wifi_ssid is defined and machine_wifi_ssid | length > 0
        and machine_wifi_interface is defined and machine_wifi_interface | length > 0
      failed_when: false
      changed_when: false

    - name: (~90%) Probe camera reachability on configured camera interfaces
      shell: |
        for iface in {{ (camera_static_config | default([])) | map(attribute='name') | join(' ') }}; do
          [ -z "$iface" ] && continue
          # Leave internet-capable interfaces untouched.
          ping -c 1 -W 2 -I "$iface" 8.8.8.8 >/dev/null 2>&1 && continue
          ping -c 1 -W 2 -I "$iface" "{{ camera_probe_ip }}" >/dev/null 2>&1 && echo "$iface" || true
        done
      register: camera_ping_ifaces_configured
      changed_when: false
      failed_when: false
      when: camera_static_config is defined and camera_static_config | length > 0

    - name: (~90%) Probe camera reachability on other ethernet interfaces with temporary IP (non-fatal)
      shell: |
        probe_ip="{{ camera_probe_ip }}"
        temp_ip="{{ camera_probe_temp_ip }}"
        internet_if="{{ internet_interface | default('') }}"
        configured_ifaces="{{ (camera_static_config | default([])) | map(attribute='name') | join(' ') }}"

        for iface in {{ ethernet_ifaces_raw.stdout_lines | default([]) | join(' ') }}; do
          [ -z "$iface" ] && continue
          [ -n "$internet_if" ] && [ "$iface" = "$internet_if" ] && continue
          # Leave internet-capable interfaces untouched.
          ping -c 1 -W 2 -I "$iface" 8.8.8.8 >/dev/null 2>&1 && continue
          case " $configured_ifaces " in
            *" $iface "*) continue ;;
          esac

          ip link set "$iface" up >/dev/null 2>&1 || true
          added_temp=0
          if ! ip -4 addr show dev "$iface" | grep -qE 'inet 192\.168\.1\.'; then
            ip addr add "${temp_ip}/24" dev "$iface" >/dev/null 2>&1 && added_temp=1 || true
          fi

          if ping -c 1 -W 2 -I "$iface" "$probe_ip" >/dev/null 2>&1; then
            echo "$iface"
          fi

          [ "$added_temp" -eq 1 ] && ip addr del "${temp_ip}/24" dev "$iface" >/dev/null 2>&1 || true
        done
      register: camera_ping_ifaces_fallback
      changed_when: false
      failed_when: false
      when: ethernet_ifaces_raw.stdout_lines | default([]) | length > 0

    - name: (~95%) Set camera reachability facts
      set_fact:
        camera_probe_success_ifaces: "{{ ((camera_ping_ifaces_configured.stdout_lines | default([])) + (camera_ping_ifaces_fallback.stdout_lines | default([]))) | select('match', '^[a-zA-Z]') | unique | list }}"
        camera_setup_needs_manual: "{{ ((((camera_ping_ifaces_configured.stdout_lines | default([])) + (camera_ping_ifaces_fallback.stdout_lines | default([]))) | select('match', '^[a-zA-Z]') | list) | length) == 0 }}"

    - name: (~95%) Warn when camera network is not reachable and needs manual setup
      debug:
        msg: |
          WARNING: Camera auto-detection could not verify connectivity to {{ camera_probe_ip }}.
          No ethernet adapter successfully reached the camera target.
          Manual setup likely required:
          - Confirm camera power/cabling and camera IP.
          - Re-run post-reboot-verify with camera connected.
          - Manually assign 192.168.1.200/24 to the camera adapter if needed.
      when: camera_setup_needs_manual | bool

    - name: (~100%) Warn networking skipped
      debug:
        msg: "⚠️  Networking configuration skipped (no interfaces matched or WiFi requested but no wireless interface found)."
      when: not (apply_machine_network | default(false) | bool)

    # ==========================================================
    # 9. TIMEZONE
    # ==========================================================
    - name: (~100%) Set timezone
      timezone:
        name: "{{ machine_timezone }}"

    - debug:
        msg: "If this machine is not in Central, set timezone manually: sudo timedatectl set-timezone <zone>"

    # ==========================================================
    # 10. FINAL SUMMARY
    # ==========================================================
    - debug:
        msg: |
          ✅ ✅ ✅ ALL VERIFICATIONS PASSED! ✅ ✅ ✅

          Machine setup complete: networking (NetworkManager + netplan), timezone ({{ machine_timezone }}).

          Your system is fully configured and ready for ML workloads:
          • NVIDIA Driver: Loaded
          • CUDA Toolkit: Available
          • Docker + NVIDIA Runtime: Working
          • ML Packages: Installed (PyTorch, ultralytics, TensorRT, onnxruntime-gpu)
          • PyTorch CUDA Support: Enabled
          • TensorRT: Verified
          • Networking: NetworkManager + 99-machine-network (DHCP + camera static; WiFi if configured)
          • Timezone: {{ machine_timezone }}

          To use the ML environment:
            source ~/code/auto_test/activate.sh

          Next: run the king_detector setup script (see king_detector repo admin/SETUP.md).

          {% if machine_wifi_ssid is defined and machine_wifi_ssid | length > 0 and machine_wifi_interface is defined and machine_wifi_interface | length > 0 %}
          ⚠️  WIFI-ONLY REMINDER: In operation this machine uses only WiFi ({{ machine_wifi_ssid }}) for internet.
          Before shipping, unplug ethernet and verify connectivity over WiFi only.
          {% endif %}

          {% if camera_setup_needs_manual | default(true) %}
          WARNING: Camera adapter auto-detection did not verify reachability to {{ camera_probe_ip }}.
          Manual camera networking setup is required.
          {% endif %}

          Log file: {{ log_file }}
